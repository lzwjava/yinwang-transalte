 1st lesson: Functions. Different from general courses, this course does not start with the "Hello World" program or ask students to do seemingly fun but actually boring small games. I begin by talking about the most fundamental concept: functions. There are only a few key points about functions, but they are the core of everything. Repeatedly practicing a few knowledge points with an empty mind allows the brain to think and transform them freely, which is the essence of teaching. I have designed appropriate exercises for each knowledge point.

The exercises for this lesson are all small, only requiring one or two lines of code, but they contain profound principles. The exercises gradually increase in difficulty, surpassing the level of doctoral courses. I have renamed all the terms to prevent students from searching related content online, so their thinking is not influenced by any existing information, and they can independently complete these exercises. Each exercise builds on the previous one, and the later exercises do not require any other foundation. Interestingly, under proper guidance, many students have completed the most difficult exercises, even those with no prior knowledge. Specific content is not disclosed for confidentiality reasons.

2nd lesson: Recursion. Recursion can be considered the most important concept in computer science (or mathematics). I start with the simplest recursive function to understand the essence of recursion and master the systematic thinking approach to recursion.

Recursion is a concept that many people believe they understand, but in reality, they have been misled by incorrect teaching methods. Many people mention recursion and only think of the "Tower of Hanoi" or "Eight Queens" problem, but they cannot apply it to solve real-world problems. Many programming books superficially emphasize the "disadvantages" of recursion and teach students how to "eliminate recursion," but they fail to address the root cause—early implementations of function calls in certain languages (such as C) were incorrect and inefficient, leading students to avoid recursion. Since they have never had a clear understanding of recursion, when they encounter complex recursive functions in their future work, they feel baffled. Differing from general data structure courses, this course focuses mainly on "functional data structures." These structures possess certain unique and useful properties. Due to their logical structure being clear, they are easier to understand compared to traditional data structure books. Unlike the Haskell community's teaching style, I will not dogmatically emphasize the advantages of pure functions, but rather objectively help students understand their benefits and discover their weaknesses. Once you have learned these structures, it is easy to extend them to non-functional structures, seamlessly combining the two styles.

4th Lesson: Trees. Extending from the basic operations of linked lists, we introduce more complex data structures—trees. Trees are one of the most common and essential data structures in computer science, so understanding tree operations is crucial. Our trees are all functional data structures.

5th Lesson: Calculator. After getting familiar with the fundamental tree operations, we implement a relatively advanced calculator that can calculate any nested arithmetic expressions. Arithmetic expressions are a type of "expression tree." Students will understand the principle "expressions are a tree" from this exercise.

6th Lesson: Search Structures. Understand how to implement key-value search structures and personally implement two important search data structures. Our search structures are all functional data structures. These structures will play a significant role in later interpreters, deepening and solidifying students' understanding.

7th Lesson: Interpreter. Leveraging the foundation laid earlier, personally implement the most important and often considered hard-to-understand concept in computer science—interpreters. Interpreters are essential for understanding various computer science concepts, such as programming languages, operating systems, databases, network protocols, and web frameworks. The computer's most fundamental component, the CPU, is essentially an interpreter. Understanding interpreters will help you understand "computer system architecture," or the computer's "hardware." You will find that this hardware is not significantly different from software. Interpreters can be considered "computation itself," making them an invaluable area of study. Deep comprehension of interpreters will also aid in understanding various other subjects, such as natural language processing, logic, and more. Lesson 8: Python. Explain the concept of "object-oriented programming" using Python. Previously used elements of object-oriented programming, so this lesson with Python is just to connect it with "practical programming" and help students understand how the ideas learned before can be applied to real-world code. This lesson will also cover the basic usage of other command-line languages such as arrays, assignment, loops, etc.

Python is popular nowadays due to the "AI hype." I don't care about AI, but Python is a good choice as a tool to understand "object-oriented programming." Although some people (like me) may not care about "object-oriented," understanding other people's concept of "object-oriented" is helpful for practical work, otherwise, you'll have a hard time understanding such code.

Lesson 9: Java. Use Java to introduce the "static type system" as an essential tool for creating large-scale projects and ensuring basic quality. Through Java's type system, students will master the fundamental static type checking rules and essential concepts like generics. This foundation will prepare students for other similar languages such as C++, C#, Rust, etc.

Java may be criticized by some "functional programmers" for being too complex, but once you master the essential programming techniques, you can write simple and high-quality code with Java. Java is still widely used in the web server domain and is the most reliable language in that regard.

Lesson 10: Rust. Rust is the current popular emerging language, but most of its features are already present in other languages; Rust just selects the best parts and includes some design errors of its own. Rust's unique feature is "static memory management," which means ensuring memory safety without "garbage collection" (GC) through a static type system. In this lesson, we will learn the basics of memory management and understand Rust's ownership, lifetimes, and other essential concepts. If time permits, we will also use Rust to understand other important type system features. Through Rust, I have understood memory management. This will also help students understand C, C++, and other languages that have "manual memory management." It lays a foundation for low-level system programming.